"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Blockchain = exports.toSandboxContract = exports.SANDBOX_CONTRACT_SYMBOL = void 0;
const defaultConfig_1 = require("../config/defaultConfig");
const core_1 = require("@ton/core");
const Executor_1 = require("../executor/Executor");
const BlockchainStorage_1 = require("./BlockchainStorage");
const Event_1 = require("../event/Event");
const BlockchainContractProvider_1 = require("./BlockchainContractProvider");
const BlockchainSender_1 = require("./BlockchainSender");
const Treasury_1 = require("../treasury/Treasury");
const AsyncLock_1 = require("../utils/AsyncLock");
const message_1 = require("../utils/message");
const slimConfig_1 = require("../config/slimConfig");
const testTreasurySubwalletId_1 = require("../utils/testTreasurySubwalletId");
const CREATE_WALLETS_PREFIX = 'CREATE_WALLETS';
function createWalletsSeed(idx) {
    return `${CREATE_WALLETS_PREFIX}${idx}`;
}
const LT_ALIGN = 1000000n;
exports.SANDBOX_CONTRACT_SYMBOL = Symbol('SandboxContract');
function toSandboxContract(contract) {
    if (contract[exports.SANDBOX_CONTRACT_SYMBOL] === true) {
        return contract;
    }
    throw new Error('Invalid contract: not a sandbox contract');
}
exports.toSandboxContract = toSandboxContract;
const TREASURY_INIT_BALANCE_TONS = 1000000;
function blockchainConfigToBase64(config) {
    switch (config) {
        case 'default':
            return defaultConfig_1.defaultConfig;
        case 'slim':
            return slimConfig_1.slimConfig;
        default:
            return config?.toBoc({ idx: false }).toString('base64') ?? defaultConfig_1.defaultConfig;
    }
}
class Blockchain {
    snapshot() {
        return {
            contracts: this.storage.knownContracts().map(s => s.snapshot()),
            networkConfig: this.networkConfig,
            lt: this.currentLt,
            time: this.currentTime,
            verbosity: { ...this.logsVerbosity },
            libs: this.globalLibs,
            nextCreateWalletIndex: this.nextCreateWalletIndex,
        };
    }
    async loadFrom(snapshot) {
        this.storage.clearKnownContracts();
        for (const contract of snapshot.contracts) {
            const storageContract = await this.getContract(contract.address);
            storageContract.loadFrom(contract);
        }
        this.networkConfig = snapshot.networkConfig;
        this.currentLt = snapshot.lt;
        this.currentTime = snapshot.time;
        this.logsVerbosity = { ...snapshot.verbosity };
        this.globalLibs = snapshot.libs;
        this.nextCreateWalletIndex = snapshot.nextCreateWalletIndex;
    }
    get now() {
        return this.currentTime;
    }
    set now(now) {
        this.currentTime = now;
    }
    get lt() {
        return this.currentLt;
    }
    constructor(opts) {
        this.currentLt = 0n;
        this.messageQueue = [];
        this.logsVerbosity = {
            print: true,
            blockchainLogs: false,
            vmLogs: 'none',
            debugLogs: true,
        };
        this.lock = new AsyncLock_1.AsyncLock();
        this.contractFetches = new Map();
        this.nextCreateWalletIndex = 0;
        this.networkConfig = blockchainConfigToBase64(opts.config);
        this.executor = opts.executor;
        this.storage = opts.storage;
    }
    get config() {
        return core_1.Cell.fromBase64(this.networkConfig);
    }
    get configBase64() {
        return this.networkConfig;
    }
    async sendMessage(message, params) {
        await this.pushMessage(message);
        return await this.runQueue(params);
    }
    async sendMessageIter(message, params) {
        params = {
            now: this.now,
            ...params,
        };
        await this.pushMessage(message);
        // Iterable will lock on per tx basis
        return await this.txIter(true, params);
    }
    async runTickTock(on, which, params) {
        for (const addr of (Array.isArray(on) ? on : [on])) {
            await this.pushTickTock(addr, which);
        }
        return await this.runQueue(params);
    }
    async runGetMethod(address, method, stack = [], params) {
        return await (await this.getContract(address)).get(method, stack, {
            now: this.now,
            ...params,
        });
    }
    async pushMessage(message) {
        const msg = message instanceof core_1.Cell ? (0, core_1.loadMessage)(message.beginParse()) : message;
        if (msg.info.type === 'external-out') {
            throw new Error('Cannot send external out message');
        }
        await this.lock.with(async () => {
            this.messageQueue.push({
                type: 'message',
                ...msg,
            });
        });
    }
    async pushTickTock(on, which) {
        await this.lock.with(async () => {
            this.messageQueue.push({
                type: 'ticktock',
                on,
                which,
            });
        });
    }
    async runQueue(params) {
        const txes = await this.processQueue(params);
        return {
            transactions: txes,
            events: txes.map(tx => tx.events).flat(),
            externals: txes.map(tx => tx.externals).flat(),
        };
    }
    txIter(needsLocking, params) {
        const it = { next: () => this.processTx(needsLocking, params), [Symbol.asyncIterator]() { return it; } };
        return it;
    }
    async processInternal(params) {
        let result = undefined;
        let done = this.messageQueue.length == 0;
        while (!done) {
            const message = this.messageQueue.shift();
            let tx;
            if (message.type === 'message') {
                if (message.info.type === 'external-out') {
                    done = this.messageQueue.length == 0;
                    continue;
                }
                this.currentLt += LT_ALIGN;
                tx = await (await this.getContract(message.info.dest)).receiveMessage(message, params);
            }
            else {
                this.currentLt += LT_ALIGN;
                tx = await (await this.getContract(message.on)).runTickTock(message.which, params);
            }
            const transaction = {
                ...tx,
                events: (0, Event_1.extractEvents)(tx),
                parent: message.parentTransaction,
                children: [],
                externals: [],
            };
            transaction.parent?.children.push(transaction);
            result = transaction;
            done = true;
            for (const message of transaction.outMessages.values()) {
                if (message.info.type === 'external-out') {
                    transaction.externals.push({
                        info: {
                            type: 'external-out',
                            src: message.info.src,
                            dest: message.info.dest ?? undefined,
                            createdAt: message.info.createdAt,
                            createdLt: message.info.createdLt,
                        },
                        init: message.init ?? undefined,
                        body: message.body,
                    });
                    continue;
                }
                this.messageQueue.push({
                    type: 'message',
                    parentTransaction: transaction,
                    ...message,
                });
                if (message.info.type === 'internal') {
                    this.startFetchingContract(message.info.dest);
                }
            }
        }
        return result === undefined ? { value: result, done: true } : { value: result, done: false };
    }
    async processTx(needsLocking, params) {
        // Lock only if not locked already
        return needsLocking ? await this.lock.with(async () => this.processInternal(params)) : await this.processInternal(params);
    }
    async processQueue(params) {
        params = {
            now: this.now,
            ...params,
        };
        return await this.lock.with(async () => {
            // Locked already
            const txs = this.txIter(false, params);
            const result = [];
            for await (const tx of txs) {
                result.push(tx);
            }
            return result;
        });
    }
    provider(address, init) {
        return new BlockchainContractProvider_1.BlockchainContractProvider({
            getContract: (addr) => this.getContract(addr),
            pushMessage: (msg) => this.pushMessage(msg),
            runGetMethod: (addr, method, args) => this.runGetMethod(addr, method, args),
            pushTickTock: (on, which) => this.pushTickTock(on, which),
            openContract: (contract) => this.openContract(contract),
        }, address, init);
    }
    sender(address) {
        return new BlockchainSender_1.BlockchainSender({
            pushMessage: (msg) => this.pushMessage(msg),
        }, address);
    }
    treasuryParamsToMapKey(workchain, seed) {
        return `${workchain}:${seed}`;
    }
    async treasury(seed, params) {
        const subwalletId = (0, testTreasurySubwalletId_1.testSubwalletId)(seed);
        const wallet = this.openContract(Treasury_1.TreasuryContract.create(params?.workchain ?? 0, subwalletId));
        const contract = await this.getContract(wallet.address);
        if ((params?.predeploy ?? true) && (contract.accountState === undefined || contract.accountState.type === 'uninit')) {
            await this.sendMessage((0, message_1.internal)({
                from: new core_1.Address(0, Buffer.alloc(32)),
                to: wallet.address,
                value: (0, core_1.toNano)(1),
                stateInit: wallet.init,
            }));
            contract.balance = params?.balance ?? (0, core_1.toNano)(TREASURY_INIT_BALANCE_TONS);
        }
        else if ((params?.resetBalanceIfZero ?? true) && contract.balance === 0n) {
            contract.balance = params?.balance ?? (0, core_1.toNano)(TREASURY_INIT_BALANCE_TONS);
        }
        return wallet;
    }
    async createWallets(n, params) {
        const wallets = [];
        for (let i = 0; i < n; i++) {
            const seed = createWalletsSeed(this.nextCreateWalletIndex++);
            wallets.push(await this.treasury(seed, params));
        }
        return wallets;
    }
    openContract(contract) {
        let address;
        let init = undefined;
        if (!core_1.Address.isAddress(contract.address)) {
            throw Error('Invalid address');
        }
        address = contract.address;
        if (contract.init) {
            if (!(contract.init.code instanceof core_1.Cell)) {
                throw Error('Invalid init.code');
            }
            if (!(contract.init.data instanceof core_1.Cell)) {
                throw Error('Invalid init.data');
            }
            init = contract.init;
        }
        const provider = this.provider(address, init);
        const blkch = this;
        return new Proxy(contract, {
            get(target, prop) {
                if (prop === exports.SANDBOX_CONTRACT_SYMBOL) {
                    return true;
                }
                const value = target[prop];
                if (typeof prop === 'string' && typeof value === 'function') {
                    if (prop.startsWith('get')) {
                        return (...args) => value.apply(target, [provider, ...args]);
                    }
                    else if (prop.startsWith('send')) {
                        return async (...args) => {
                            const ret = value.apply(target, [provider, ...args]);
                            if (ret instanceof Promise) {
                                const r = await ret;
                                return {
                                    ...await blkch.runQueue(),
                                    result: r,
                                };
                            }
                            else {
                                return {
                                    ...await blkch.runQueue(),
                                    result: ret,
                                };
                            }
                        };
                    }
                }
                return value;
            }
        });
    }
    startFetchingContract(address) {
        const addrString = address.toRawString();
        let promise = this.contractFetches.get(addrString);
        if (promise !== undefined) {
            return promise;
        }
        promise = this.storage.getContract(this, address);
        this.contractFetches.set(addrString, promise);
        return promise;
    }
    async getContract(address) {
        try {
            const contract = await this.startFetchingContract(address);
            return contract;
        }
        catch (e) {
            throw e;
        }
        finally {
            this.contractFetches.delete(address.toRawString());
        }
    }
    get verbosity() {
        return this.logsVerbosity;
    }
    set verbosity(value) {
        this.logsVerbosity = value;
    }
    async setVerbosityForAddress(address, verbosity) {
        const contract = await this.getContract(address);
        contract.setVerbosity(verbosity);
    }
    setConfig(config) {
        this.networkConfig = blockchainConfigToBase64(config);
    }
    async setShardAccount(address, account) {
        const contract = await this.getContract(address);
        contract.account = account;
    }
    get libs() {
        return this.globalLibs;
    }
    set libs(value) {
        this.globalLibs = value;
    }
    static async create(opts) {
        return new Blockchain({
            executor: await Executor_1.Executor.create(),
            storage: opts?.storage ?? new BlockchainStorage_1.LocalBlockchainStorage(),
            ...opts
        });
    }
}
exports.Blockchain = Blockchain;
